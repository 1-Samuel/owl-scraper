package main

import (
	"encoding/json"
	"log"
	"net/http"
	"strconv"
	"time"
)

type Repository interface {
	Get() ([]Match, error)
	Persist(match Match) error
	PersistActive(activeMatch ActiveMatch) error
}

type Scraper struct {
	repo        Repository
	matchCount  int
	pageCount   int
	matchActive bool
}

func (s *Scraper) start() {
	s.fetch(1)
	log.Printf("Fetched %d matches from %d pages", s.matchCount, s.pageCount)
}

func (s *Scraper) activeMatch() {
	url := "https://pk0yccosw3.execute-api.us-east-2.amazonaws.com/production/v2/content-types/match-ticker/?locale=en-us"
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		panic("error creating request")
	}

	setHeaders(req)

	client := http.Client{}

	resp, err := client.Do(req)

	if err != nil {
		panic(err)
	}

	defer resp.Body.Close() // TODO log error

	if resp.StatusCode != http.StatusOK {
		s.matchActive = false
		s.start()
		return
	}

	response := new(ActiveMatchesResponse)
	err = json.NewDecoder(resp.Body).Decode(response)

	if err != nil || len(response.Data) == 0 {
		s.matchActive = false
		s.start()
	}

	for _, data := range response.Data {
		match := ActiveMatch{
			UID:         data.Uid,
			Teams:       convertTeamsColored(data),
			Status:      data.Status,
			TimeToMatch: data.TimeToMatch,
			LinkToMatch: data.LinkToMatch,
			IsEncore:    data.IsEncore,
			MatchDate:   time.Time(data.MatchDate),
		}
		err := s.repo.PersistActive(match)
		if err != nil {
			panic(err)
		}
		log.Printf("Found active match %s %d:%d %s in %s", match.Teams[0].AbbreviatedName, match.Teams[0].Score, match.Teams[1].Score, match.Teams[1].AbbreviatedName, time.Duration(match.TimeToMatch)*time.Millisecond)
	}

}

func (s *Scraper) fetch(weekNumber int) {
	url := s.generateUrl(weekNumber)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		panic("error creating request")
	}

	setHeaders(req)

	client := http.Client{}

	resp, err := client.Do(req)

	if err != nil {
		panic(err)
	}

	defer resp.Body.Close() // TODO log error

	if resp.StatusCode != http.StatusOK {
		panic("could not get matches from api")
	}

	response := new(AutoGeneratedResponse)
	err = json.NewDecoder(resp.Body).Decode(response)

	for _, event := range response.Data.TableData.Events {
		for _, match := range event.Matches {
			teams := convertTeams(match)
			match := convertMatch(match, teams, event)
			err := s.repo.Persist(match)
			if err != nil {
				panic(err)
			} else {
				s.matchCount++
			}
		}
	}

	s.pageCount++

	pagination := response.Data.TableData.Pagination

	if pagination.NextPage < pagination.TotalPages {
		time.Sleep(2 * time.Second)
		s.fetch(pagination.NextPage)
	}
}

func (s *Scraper) generateUrl(weekNumber int) string {
	urlPrefix := "https://pk0yccosw3.execute-api.us-east-2.amazonaws.com/production/v2/content-types/schedule/blt27f16f110b3363f7/week/"
	urlSuffix := "/team/allteams?locale=en-us"
	return urlPrefix + strconv.Itoa(weekNumber) + urlSuffix
}

func (s *Scraper) isMatchActive() bool {
	if s.matchActive == true {
		return true
	}
	matches, err := s.repo.Get()
	if err != nil {
		return false
	}
	for _, match := range matches {
		if match.Status != "CONCLUDED" && match.Start.Add(-time.Hour).Before(time.Now()) {
			s.matchActive = true
			log.Printf("New active match: %s - %s at %s", match.Teams[0].AbbreviatedName, match.Teams[1].AbbreviatedName, match.Start)
			return s.matchActive
		}
	}
	return s.matchActive
}

func setHeaders(req *http.Request) {
	req.Header.Add("Host", "pk0yccosw3.execute-api.us-east-2.amazonaws.com")
	req.Header.Add("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/112.0")
	req.Header.Add("Accept", "*/*")
	req.Header.Add("Accept-Language", "en-US,en;q=0.5")
	req.Header.Add("Accept-Encoding", "gzip, deflate, br")
	req.Header.Add("Referer", "https://overwatchleague.com/")
	req.Header.Add("x-origin", "overwatchleague.com")
	req.Header.Add("Origin", "https://overwatchleague.com")
	req.Header.Add("DNT", "1")
	req.Header.Add("Connection", "keep-alive")
	req.Header.Add("Sec-Fetch-Dest", "empty")
	req.Header.Add("Sec-Fetch-Mode", "cors")
	req.Header.Add("Sec-Fetch-Site", "cross-site")
	req.Header.Add("TE", "trailers")
}
